## Docker/containers



<details>
  <summary>Что такое Docker? В чем отличие контейнера от образа?</summary>

Docker - программное обеспечение для автоматизации развёртывания и управления приложениями в средах с поддержкой контейнеризации.

Образ - шаблон приложения, который содержит слои файловой системы в режиме "только-чтение".

Контейнер - запущенный образ приложения, который кроме нижних слоев в режиме "только чтение" содержит верхний слой в режиме "чтение-запись".

</details>


<details>
  <summary>Какие инструкции есть у Dockerfile?</summary>

| Инструкция | Описание |
|------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| FROM | Задаёт базовый (родительский) образ. |
| LABEL | Описывает метаданные. Например — сведения о том, кто создал и поддерживает образ. |
| ENV | Устанавливает постоянные переменные среды. |
| RUN | Выполняет команду и создаёт слой образа. Используется для установки в контейнер пакетов. |
| COPY | Копирует в контейнер файлы и директории. |
| ADD | Копирует файлы и директории в контейнер, может распаковывать локальные .tar-файлы. |
| CMD | Описывает команду с аргументами, которую нужно выполнить когда контейнер будет запущен. Аргументы могут быть переопределены при запуске контейнера. В файле может присутствовать лишь одна инструкция CMD. |
| WORKDIR | Задаёт рабочую директорию для следующей инструкции. |
| ARG | Задаёт переменные для передачи Docker во время сборки образа. |
| ENTRYPOINT | Предоставляет команду с аргументами для вызова во время выполнения контейнера. Аргументы не переопределяются. |
| EXPOSE | Указывает на необходимость открыть порт. |
| VOLUME | Создаёт точку монтирования для работы с постоянным хранилищем. |

</details>



<details>
  <summary>Чем отличается *CMD* от *ENTRYPOINT* в Dockerfile?</summary>

Инструкции CMD и ENTRYPOINT выполняются в момент запуска контейнера, тольо инструкция CMD позволяет переопределить передаваемые команде аргументы.

**Пример 1. CMD:**
Опишем сборку образа в Dockerfile.
```
FROM alpine  
CMD ["ping", "8.8.8.8"]  
```
В инструкцию CMD передаются 2 аргумента. Выполним сборку образа `docker build -t test .` и запустим контейнер.
```
$ docker run test
PING 8.8.8.8 (8.8.8.8): 56 data bytes
64 bytes from 8.8.8.8: seq=0 ttl=43 time=32.976 ms
64 bytes from 8.8.8.8: seq=1 ttl=43 time=31.998 ms
64 bytes from 8.8.8.8: seq=2 ttl=43 time=31.843 ms
--- 8.8.8.8 ping statistics ---
3 packets transmitted, 3 packets received, 0% packet loss
round-trip min/avg/max = 31.708/33.316/36.823 ms
```
Теперь передадим 2 новых аргумента для запуска контейнера.
```
$ docker run test traceroute 1.1.1.1
traceroute to 1.1.1.1 (1.1.1.1), 30 hops max, 46 byte packets
 1  172.17.0.1 (172.17.0.1)  0.017 ms  0.016 ms  0.009 ms
 2  192.168.168.1 (192.168.168.1)  0.996 ms  1.553 ms  2.069 ms
 3  *  *  *
 4  lag-2-435.bgw01.samara.ertelecom.ru (85.113.62.125)  1.454 ms  1.427 ms  1.984 ms
 5  172.68.8.3 (172.68.8.3)  19.685 ms  15.722 ms  15.565 ms
 6  172.68.8.2 (172.68.8.2)  15.846 ms  22.696 ms  35.093 ms
 7  one.one.one.one (1.1.1.1)  17.439 ms  17.670 ms  24.202 ms
```
`ping` заменен на traceroute, IP адрес заменен на 1.1.1.1.

**Пример 2. ENTRYPOINT:**
Опишем сборку образа в Dockerfile.
```
FROM alpine  
ENTRYPOINT ["ping", "8.8.8.8"]
```
В инструкцию ENTRYPOINT передаются 2 аргумента. Выполним сборку образа `docker build -t test .` и запустим контейнер.
```
$ docker run test2
PING 8.8.8.8 (8.8.8.8): 56 data bytes
64 bytes from 8.8.8.8: seq=0 ttl=43 time=36.189 ms
64 bytes from 8.8.8.8: seq=1 ttl=43 time=44.120 ms
64 bytes from 8.8.8.8: seq=2 ttl=43 time=44.584 ms
^C
--- 8.8.8.8 ping statistics ---
3 packets transmitted, 3 packets received, 0% packet loss
round-trip min/avg/max = 36.189/41.631/44.584 ms
```
Теперь передадим изменим один из аргументов для запуска контейнера.
```
$ docker run test2 ping 1.1.1.1
BusyBox v1.31.1 () multi-call binary.

Usage: ping [OPTIONS] HOST

Send ICMP ECHO_REQUEST packets to network hosts

	-4,-6		Force IP or IPv6 name resolution
	-c CNT		Send only CNT pings
	-s SIZE		Send SIZE data bytes in packets (default 56)
	-i SECS		Interval
	-A		Ping as soon as reply is recevied
	-t TTL		Set TTL
	-I IFACE/IP	Source interface or IP address
	-W SEC		Seconds to wait for the first response (default 10)
			(after all -c CNT packets are sent)
	-w SEC		Seconds until ping exits (default:infinite)
			(can exit earlier with -c CNT)
	-q		Quiet, only display output at start
			and when finished
	-p HEXBYTE	Pattern to use for payload
```
Как видим, аргумент передать контейнеру нельзя.

**Пример 3. ENTRYPOINT и CMD:**
Опишем сборку образа в Dockerfile.
```
FROM alpine  
ENTRYPOINT ["ping"]
CMD ["8.8.8.8"]
```
В инструкцию ENTRYPOINT передаётся аргумент `ping`, в CMD передаётся аргумент 8.8.8.8. Выполним сборку образа `docker build -t test .` и запустим контейнер.
```
$ docker run test3
PING 8.8.8.8 (8.8.8.8): 56 data bytes
64 bytes from 8.8.8.8: seq=0 ttl=43 time=41.176 ms
64 bytes from 8.8.8.8: seq=1 ttl=43 time=32.875 ms
64 bytes from 8.8.8.8: seq=2 ttl=43 time=40.395 ms
^C
--- 8.8.8.8 ping statistics ---
3 packets transmitted, 3 packets received, 0% packet loss
round-trip min/avg/max = 32.875/38.148/41.176 ms
```
Пробуем изменить 2 аргумента.
```
$ docker run test3 traceroute 1.1.1.1
BusyBox v1.31.1 () multi-call binary.

Usage: ping [OPTIONS] HOST

Send ICMP ECHO_REQUEST packets to network hosts

	-4,-6		Force IP or IPv6 name resolution
	-c CNT		Send only CNT pings
	-s SIZE		Send SIZE data bytes in packets (default 56)
	-i SECS		Interval
	-A		Ping as soon as reply is recevied
	-t TTL		Set TTL
	-I IFACE/IP	Source interface or IP address
	-W SEC		Seconds to wait for the first response (default 10)
			(after all -c CNT packets are sent)
	-w SEC		Seconds until ping exits (default:infinite)
			(can exit earlier with -c CNT)
	-q		Quiet, only display output at start
			and when finished
	-p HEXBYTE	Pattern to use for payload
```
Изменить 2 аргумента невозможно. Заменим аргумент инструкции CMD.
```
$ docker run test3 1.1.1.1    
PING 1.1.1.1 (1.1.1.1): 56 data bytes
64 bytes from 1.1.1.1: seq=0 ttl=58 time=31.412 ms
64 bytes from 1.1.1.1: seq=1 ttl=58 time=19.400 ms
64 bytes from 1.1.1.1: seq=2 ttl=58 time=15.814 ms
^C
--- 1.1.1.1 ping statistics ---
3 packets transmitted, 3 packets received, 0% packet loss
round-trip min/avg/max = 15.814/22.208/31.412 ms
```
При такой сборке образа команды ENTRYPOINT и CMD при запуске контейнера будут запущены последовательно, но аргумент возможно изменить только для CMD.

</details>



<details>
  <summary>Чем отличается *COPY* от *ADD* в Dockerfile?</summary>

Инструкция *COPY* копируют файлы и директории с хостовой машины внутрь контейнера, инструкция *ADD* копирует файлы и директории с хостовой машины внутрь контейнера и может распаковывать .tar архивы.

</details>



<details>
  <summary>Какие есть best practices для написания Dockerfile?</summary>

1. Запускать только один процесс на контейнер.
2. Стараться объединять несколько команд RUN в одну для уменьшения количества слоёв образа.
3. Частоизменяемые слои образа необходимо располагать ниже по уровню, чтобы ускорить процесс сборки, т.к. при изменении верхнего слоя, все нижеследующие слои будут пересобираться.
4. Указывать явные версии образов в инструкции FROM, чтобы избежать случая, когда выйдет новая версия образа с тегом latest.
5. При установке пакетов указывать версии пакетов.
6. Очищать кеш пакетного менеджера и удалять ненужные файлы после выполненной инструкции.
7. Использовать multistage build для сборки артифакта в одном контейнере и размещении его в другом.

</details>


<details>
  <summary>Какие типы сетевых драйверов используются в docker?</summary>

Основные драйвера сетей docker: bridge, host, overlay, ipvlan, macvlan, none

**bridge:** это сетевой драйвер по умолчанию. Бридж сеть используется, когда ваши приложения запускаются в автономных контейнерах, которые должны взаимодействовать между собой. 
![docker-bridge](imgs/docker-bridge.png)
Взаимодействие с хостом выполняется через мост docker0 и конфигурацию таблицы iptables nat. В этом режиме будет выделено сетевое пространство имен, задан IP-адрес для каждого контейнера, а контейнер Docker на хосте будет подключен к виртуальному мосту. Виртуальный мост работает как физический коммутатор, поэтому все контейнеры на хосте подключены к сети уровня 2 через коммутатор.

**host:** использует сеть хоста напрямую без изоляции контейнера и хоста.

**none:** этот режим помещает контейнер в свой собственный сетевой стек, но не выполняет никакой настройки. Фактически, этот режим отключает сетевую функцию контейнера, что полезно в следующих двух ситуациях: контейнер не требует сети (например, только для пакетной задачи записи дисковых томов).

**macvlan:** в режиме Macvlan Bridge каждый контейнер имеет уникальный MAC-адрес, который используется для отслеживания сопоставления MAC-адреса с портом хоста Docker. Сеть драйвера Macvlan подключается к родительскому интерфейсу хоста Docker. Примерами являются физические интерфейсы, такие как eth0, субинтерфейс eth0.10 для тегирования VLAN 802.1q (.10 означает VLAN 10) или даже связанный хост-адаптер, который объединяет два интерфейса Ethernet в единый логический интерфейс. Назначенный шлюз является внешним по отношению к хосту, предоставляемому сетевой инфраструктурой. Каждая сеть Docker в режиме Macvlan Bridge изолирована друг от друга, и только одна сеть может быть подключена к родительскому узлу одновременно. Каждый хост-адаптер имеет теоретический предел, и каждый хост-адаптер может подключаться к сети Docker. Любой контейнер в той же подсети может взаимодействовать с любым другим контейнером в той же сети без шлюзового моста macvlan. Та же сетевая команда docker применяется к драйверу vlan. В режиме Macvlan без внешней маршрутизации процессов между двумя сетями / подсетями контейнеры в разных сетях не могут получить доступ друг к другу. Это также относится к нескольким подсетям в одной и той же терминальной сети.

**overlay:** Оверлейные сети соединяют несколько демонов Docker вместе и позволяют сервисам swarm взаимодействовать друг с другом. Вы также можете использовать оверлейные сети для облегчения связи между сервисом swarm и автономным контейнером или между двумя автономными контейнерами в разных демонах Docker. Эта стратегия устраняет необходимость выполнять маршрутизацию между этими контейнерами на уровне ОС.

**ipvlan:** Сети ipvlan предоставляют пользователям полный контроль над адресацией IPv4 и IPv6. Драйвер VLAN построен на основе этой возможности, предоставляя операторам полный контроль над тегированием VLAN уровня 2 и даже маршрутизацией IPvlan L3 для пользователей.

</details>


<details>
  <summary>Что такое эфемерные контейнеры?</summary>

[Эфемерные контейнеры](https://kubernetes.io/docs/concepts/workloads/pods/ephemeral-containers/) стали бета-функцией в Kubernetes v1.23 и теперь включены по умолчанию.
Эфемерные контейнеры предназначены для транзитных задач, когда вам нужно временно [подключить дополнительный контейнер к существующему поду](https://kubernetes.io/docs/tasks/debug/debug-application/debug-running-pod/#ephemeral-container). Это идеально подходит для отладочных операций, когда вы хотите проверить поды, не затрагивая живые экземпляры контейнеров.

</details>



<details>
  <summary>Что такое namespace?</summary>

Все инструменты контейнеризации — будь то Docker, LXC или systemd-nspawn,— основываются на двух подсистемах ядра Linux: namespaces и cgroups.  Пространство имён (англ. namespace) — это механизм ядра Linux, обеспечивающий изоляцию процессов друг от друга. Работа по его реализации была начата в версии ядра 2.4.19.На текущий момент в Linux поддерживается шесть типов пространств имён:

Пространство имён    	    Что изолирует
```
PID			PID процессов
NETWORK			Сетевые устройства, стеки, порты и т.п.
USER			ID пользователей и групп
MOUNT			Точки монтирования
IPC			SystemV IPC, очереди сообщений POSIX
UTS			Имя хоста и доменное имя NIS		
```		
	

Все эти типы используются современными системами контейнеризации (Docker, LXC и другими) при запуске программ.

</details>


<details>
  <summary>Что такое контейнер(Docker)?</summary>
Это изолированя среда с инструментами, средой выполнения, библиотеками, зависимостями и файлами конфигурациями для запуска приложения или сервиса. Отличия от вм, что нету оси, вместо нее используется двжок инструмента контейнеризации(Docker, K8s, podman,lxc,buildah)


</details>


### Docker Architecture

<details>
<summary>Какие компоненты/слои составляют технологию Docker?</summary><br><b>

1. Среда выполнения - отвечает за запуск и остановку контейнеров
2. Daemon - реализует Docker API и заботится об управлении образами (включая сборки), аутентификации, безопасности, создании сетей и т.д.
3. Orchestrator
</b></details>

<details>
<summary>Какие компоненты являются частью движка Docker?</summary><br><b>

  - Docker daemon
  - containerd
  - runc
</b></details>

<details>
<summary>Что такое низкоуровневая среда выполнения?</summary><br><b>

   Низкоуровневая среда выполнения называется runc
- Он управляет каждым контейнером, запущенным на хосте Docker
- Его цель - взаимодействовать с базовой ОС для запуска и остановки контейнеров
- Его эталонная реализация относится к OCI (Open Containers Initiative) container-runtime-spec
- Это небольшая CLI-оболочка для libcontainer
</b></details>

<details>
<summary>Что такое высокоуровневая среда выполнения?</summary><br><b>

  - Высокоуровневая среда выполнения называется containerd
- Он был разработан Docker Inc и в какой-то момент передан в дар CNCF
- Он управляет всем жизненным циклом контейнера - запуском, остановкой, удалением и приостановкой
- Он заботится о настройке сетевых интерфейсов, громкости, передаче и извлечении изображений...
- Он управляет экземплярами среды выполнения более низкого уровня (runc)
- Он используется как Docker, так и Kubernetes в качестве контейнерной среды выполнения
- Он находится между демоном Docker и runc на уровне OCI

Примечание: запустив `ps -ef | grep -i containerd` в системе с установленным и запущенным Docker, вы должны увидеть процесс containerd
</b></details>

<details>
<summary>Верно или ложно? Демон docker (dockerd) выполняет задачи более низкого уровня по сравнению с containerd</summary><br><b>

Ложный. Демон Docker выполняет задачи более высокого уровня по сравнению с containerd.<br>
Он отвечает за управление сетями, томами, изображениями...
</b></details>

<details>
<summary>Опишите подробно, что происходит, когда вы запускаете `docker pull image:tag`?</summary><br><b>
Docker CLI передает ваш запрос демону Docker. В журналах Dockerd показан процесс

docker.io/library/busybox:latest преобразован в объект manifestList с 9 записями; поиск неизвестного совпадения/amd64

найдено совпадение для linux/amd64 с типом носителя application/vnd.docker.distribution.manifest.v2+json, дайджест sha256:400ee2ed939df769d4681023810d2e4fb9479b8401d97003c710d0e20f7c49c6

вытягивание большого двоичного объекта \"sha256:61c5ed1cbdf8e801f3b73d906c61261ad916b2532d6756e7c4fbcacb975299fb Загрузил 61c5ed1cbdf8 во временный файл /var/lib/docker/tmp/GetImageBlob909736690

Применение tar в /var/lib/docker/overlay2/507df36fe373108f19df4b22a07d10de7800f33c9613acb139827ba2645444f7/diff" storage-driver=overlay2

Применил tar sha256:514c3a3e64d4ebf15f482c9e8909d130bcd53bcc452f0225b0a04744de7b8c43 к 507df36fe373108f19df4b22a07d10de7800f33c9613acb139827ba2645444f7, размер: 1223534
</b></details>

<details>
<summary>Подробно опишите, что происходит при запуске контейнера</summary><br><b>

1. Клиент Docker преобразует команду run в полезную нагрузку API
2. Затем он отправляет полезную нагрузку в конечную точку API, предоставляемую демоном Docker
3. Когда демон получает команду для создания нового контейнера, он выполняет вызов containerd через gRPC
4. containerd преобразует требуемый образ в пакет OCI и сообщает runc использовать этот пакет для создания контейнера
5. runc взаимодействует с ядром операционной системы, чтобы объединить различные конструкции (пространство имен, cgroups и т.д.), используемые для создания контейнера
6. Процесс контейнера запускается как дочерний процесс runc
7. Как только он запускается, runc существует
</b></details>

<details>
<summary>Истина или ложь? Уничтожение демона Docker приведет к уничтожению всех запущенных контейнеров</summary><br><b>

Ложный. Хотя в какой-то момент это было правдой, сегодня среда выполнения контейнера не является частью демона (она является частью containerd и runc), поэтому остановка или уничтожение демона не повлияет на запуск контейнеров.
</b></details>

<details>
<summary>Истина или ложь? containerd разветвляет новый экземпляр runc для каждого созданного им контейнера</summary><br><b>

Правда
</b></details>

<details>
<summary>Правда или ложь? Запуск дюжины контейнеров приведет к появлению дюжины процессов runc</summary><br><b>

Ложный. Как только контейнер создан, родительский процесс runc создается после того, как контейнер создан, родительский процесс runc существует.
</b></details>

<details>
<summary>Что такое shim в отношении Docker?</summary><br><b>

shim - это процесс, который становится родительским для контейнера, когда существует процесс runc. Он отвечает за:

- Отправку кода завершения обратно демону Docker
- Убедитесь, что контейнер не завершает работу при перезапуске демона. Это достигается путем сохранения stdout и stdin открытыми
</b></details>

<details>
<summary>Как бы вы перенесли данные из одного контейнера в другой?</summary><br><b>
</b></details>

<details>
<summary>What happens to data of the container when a container exists?</summary><br><b>
</b></details>

<details>
<summary>Как вы удаляете старые, не запущенные контейнеры?</summary><br><b>

1. Чтобы удалить один или несколько образов Docker, используйте команду docker container rm, за которой следует идентификатор контейнеров, которые вы хотите удалить.
2. Команда docker system prune удалит все остановленные контейнеры, все зависшие изображения и все неиспользуемые сети
3. docker rm $(docker ps -a -q) - Эта команда удалит все остановленные контейнеры. Команда docker ps -a -q вернет все существующие идентификаторы контейнеров и передаст их команде rm, которая удалит их. Все запущенные контейнеры удалены не будут.
</b></details>

<details>
<summary>Как клиент Docker взаимодействует с демоном?</summary><br><b>

Через локальный сокет по адресу `/var/run/docker.sock`
</b></details>

<details>
<summary>Explain Docker interlock</summary><br><b>
</b></details>

<details>
<summary>What is Docker Repository?</summary><br><b>
</b></details>

<details>
<summary>Объяснение слоев изображения краткое описание</summary><br><b>

Изображение Docker создается из серии слоев. Каждый слой представляет собой инструкцию в файле контейнера изображения/Dockerfile. Каждый слой, кроме самого последнего, доступен только для чтения.
Каждый слой представляет собой лишь набор отличий от предыдущего слоя. Слои накладываются друг на друга. Когда вы создаете новый контейнер, вы добавляете новый доступный для записи слой поверх нижележащих слоев. Этот слой часто называют “слоем контейнера”. Все изменения, внесенные в запущенный контейнер, такие как запись новых файлов, изменение существующих файлов и удаление файлов, записываются на этот тонкий слой контейнера, доступный для записи.
Основное различие между контейнером и изображением заключается в верхнем доступном для записи слое. Все записи в контейнер, которые добавляют новые или изменяют существующие данные, сохраняются в этом доступном для записи слое. Когда контейнер удаляется, доступный для записи слой также удаляется. Базовое изображение остается неизменным.
Поскольку у каждого контейнера есть свой собственный доступный для записи слой контейнера, и все изменения хранятся на этом уровне контейнера, несколько контейнеров могут совместно использовать доступ к одному и тому же базовому изображению и при этом иметь свое собственное состояние данных.

</b></details>

<details>
<summary>What best practices are you familiar related to working with containers?</summary><br><b>
</b></details>

<details>
<summary>How do you manage persistent storage in Docker?</summary><br><b>
</b></details>

<details>
<summary>How can you connect from the inside of your container to the localhost of your host, where the container runs?</summary><br><b>
</b></details>

<details>
<summary>How do you copy files from Docker container to the host and vice versa?</summary><br><b>
</b></details>

<a name="questions-docker-compose"></a>
